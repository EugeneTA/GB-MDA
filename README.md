# Message-driven architecture
## Урок 1. Принципы асинхронных и синхронных взаимодействий.
1. Воспроизвести приложение по бронированию столика в ресторане из методического указания.
2. Создать возможность снять бронь стола в ресторане синхронно и асинхронно, используя для этого номер забронированного столика.
3. Выделить логику для отправки уведомления в отдельный класс, он будет отвечать за все вопросы связанные с коммуникациями с клиентами, добавить задержку (они будет имитировать создание сообщения) и сделать вызов уведомления асинхронным.
4. Добавить автоматическое “снятие брони”. Например, раз в 20 секунд при наличии забронированных мест - бронь должна сниматься. Асинхронно, независимо от ввода-вывода. Подсказка: можно использовать таймер.
5. (*) Добавить синхронизацию бронирований для множественных асинхронных вызовов и синхронного, это значит, что бронируя столики не дожидаясь предыдущих ответов мы должны получать последовательный результат.

## Урок 2. Advanced Message Queueing Protocol (AMQP).
1. Приложение из первого урока переделать на работу с RabbitMQ. Выделенную в отдельный класс логику отправки уведомления перенести в новое консольное приложение, реализовать взаимодействие через очередь.
2. Переделать работу с очередью на шаблон publisher/subscriber (издатель/подписчик). Сообщения не должны отправляться напрямую в очередь, каждый подписчик должен получить сообщение от издателя. То есть если мы запустим пять сервисов уведомлений, каждый из них должен получить и обработать сообщение https://www.rabbitmq.com/tutorials/tutorial-three-dotnet.html
3. (*) Предложить свою реализацию библиотеки Messaging. Например, если мы захотим использовать не RabbitMQ, а нечто другое это должно быть легко переключаемым. Автоматическое переподключение к брокеру при возникновении проблем на нем. Конфигурация флагов (durable, autoack и т.д). Необходимо мыслить критически и не ограничивать себя в творчестве.

## Урок 3. Работа с MassTransit. 
1. Используя весь опыт предыдущих уроков и код из методички воспроизвести приложение описанное в тексте материала.
2. Добавить в сервис кухни неожиданные поломки или попадание блюд в стоп-лист, которые вызывают реакцию в других сервисах: отправляется уведомление о снятии брони с извинениями и происходит снятие бронирования. Никаких прямых команд между сервисами быть не должно, только данные в публикациях на которые будут реагировать остальные сервисы.
3. (*) Добавить возможность отправлять сообщение через обменник с типом direct из сервиса бронирований на кухню с синхронным ожиданием ответа. Для этого придется использовать заголовки и конфигурацию. Сообщение должно содержать следующий смысл “Когда обед?”. Кухня может отвечать от 0,5 до 3 секунд любым сообщением. Если время ответа превышает 1,5 секунд в более чем 10 случаев из последних 30 - необходимо чтобы срабатывал шаблон “Предохранитель”.

## Урок 4. State Machine. Saga.
1. Используя весь опыт предыдущих уроков и код из методички воспроизвести приложение описанное в тексте материала;
2. После подтверждения бронирования добавить статус “Ожидание гостя”. Добавить генерацию сообщения “Гость прибыл” с таймаутом в диапазоне от 7 до 15 секунд. Запуск генерации события “Гость прибыл” должен происходить только после перехода в статус “Ожидание гостя”. После получения сообщения “Гость прибыл” - сага переводится в статус Final.
3. Гость при бронировании указывает через какое время он придет. Например, через 10 секунд. Это значение должно генерироваться случайно в диапазоне от 7 до 15 секунд сервисом бронирования. Если гость не приходит указанном диапазоне после перехода в статус “Ожидание гостя” - мы должны отправить ему сообщение о том, что его бронь снята и перевести сагу в статус Final.
4. (*) Добавить персистентность используя любое из предложенных в документации хранилищ.

## Урок 5. Отказоустойчивость. Transaction Outbox.
1. Используя весь опыт предыдущих уроков и код из методички воспроизвести приложение описанное в тексте материала.
2. Настроить политики повторов и повторной доставки для всех потребителей.
3. Добавить в сервис Kitchen правило, что мы не принимаем предзаказ с типом Lasagna: добавить генерацию исключения, в сервисе бронирования реализовать каждый четвертый запрос на бронирование с Lasagna.
4. Включить Transaction Outbox для всех сервисов. Задание на отладку: добиться срабатывания работы паттерна Transaction Outbox реализованного в Mass Transit “наяву”, чтобы лучше усвоить его работу.
5. (*) Реализовать Transaction Outbox в базе данных. Заниматься вопросом работы при кластеризации и блокировке записей не нужно.

## Урок 6. Дублирование сообщений. Идемпотентность.
1. Используя весь опыт предыдущих уроков и код из методички воспроизвести приложение описанное в тексте материала;
2. Реализовать второй вариант идемпотентного потребителя - с дополнительным хранилищем (имитировать транзакционность).
3. Сделать все потребители идемпотентными.
4. Для хранилищ сообщений должны быть реализована очистка - сообщение должно удаляться через 30 секунд после появления.
5. (*) Реализовать идемпотентность через базу данных. Подумать о том, как быть при наличии нескольких инстансов сервиса.

## Урок 7. Логирование и мониторинг. Тестирование.
1. Добавить логирование во все проекты не теряя из виду уровни логирования: Debug, Info, Error. Добавить аудит сообщений во все проекты.
2. Подключить мониторинг во все проекты.
3. Покрыть тестами все потребители сообщений. Учитывать не только прямые кейсы, но и граничные случаи. Не забыть протестировать идемпотентность.
4. (*) Настроить аудит сообщений в базу данных. Добавить тесты для саги, для Scheduler и сообщений-ошибок.